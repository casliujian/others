
** Conflict (shift/reduce) in state 214.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Var Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 214, looking ahead at LB2, reducing production
** expr_single -> Var Iden Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Var Iden Equal expr_single . 

** In state 214, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Var Iden Equal expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 213.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Val Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 213, looking ahead at LB2, reducing production
** expr_single -> Val Iden Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Val Iden Equal expr_single . 

** In state 213, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Val Iden Equal expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 212.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal UIden expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 212, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

UIden expr_single 
      expr_single . With LB3 str_expr_list RB3 

** In state 212, looking ahead at With, reducing production
** expr_single -> UIden expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
UIden expr_single . 

** Conflict (shift/reduce) in state 211.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal UIden Dot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 211, looking ahead at With, reducing production
** expr_single -> UIden Dot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
UIden Dot expr_single . 

** In state 211, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

UIden Dot expr_single 
          expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 209.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Negb expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 209, looking ahead at LB2, reducing production
** expr_single -> Negb expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Negb expr_single . 

** In state 209, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Negb expr_single 
     expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 208.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 208, looking ahead at LB2, reducing production
** expr_single -> MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
MinusDot expr_single . 

** In state 208, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

MinusDot expr_single 
         expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 207.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 207, looking ahead at LB2, reducing production
** expr_single -> Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Minus expr_single . 

** In state 207, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Minus expr_single 
      expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 200.
** Token involved: ColonColon
** This state is reached from program after reading:

imported Function Iden UIden pattern 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Function Iden args option(type_of_expr) Equal expr 
                       pattern 
                       (?)

** In state 200, looking ahead at ColonColon, shifting is permitted
** because of the following sub-derivation:

UIden pattern 
      pattern . ColonColon pattern 

** In state 200, looking ahead at ColonColon, reducing production
** pattern -> UIden pattern 
** is permitted because of the following sub-derivation:

pattern ColonColon pattern // lookahead token appears
UIden pattern . 

** Conflict (shift/reduce) in state 174.
** Tokens involved: Underline UIden LB2 LB1 Int Iden Float
** The following explanations concentrate on token Underline.
** This state is reached from program after reading:

imported Function Iden UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Function Iden args option(type_of_expr) Equal expr 
                       (?)

** In state 174, looking ahead at Underline, shifting is permitted
** because of the following sub-derivation:

pattern 
UIden pattern 
      . Underline 

** In state 174, looking ahead at Underline, reducing production
** pattern -> UIden 
** is permitted because of the following sub-derivation:

pattern args // lookahead token appears because args can begin with Underline
UIden . 

** Conflict (shift/reduce) in state 171.
** Token involved: Vertical
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal LB2 Vertical Match expr_single With pattern_expr_list 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 171, looking ahead at Vertical, reducing production
** expr_single -> Match expr_single With pattern_expr_list 
** is permitted because of the following sub-derivation:

LB2 Vertical expr_single_list Vertical RB2 // lookahead token appears
             expr_single // lookahead token is inherited
             Match expr_single With pattern_expr_list . 

** In state 171, looking ahead at Vertical, shifting is permitted
** because of the following sub-derivation:

LB2 Vertical expr_single_list Vertical RB2 
             expr_single 
             Match expr_single With pattern_expr_list 
                                    pattern_expr_list . Vertical pattern_expr 

** Conflict (shift/reduce) in state 147.
** Token involved: Else
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal If expr_single Then If expr_single Then expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 147, looking ahead at Else, shifting is permitted
** because of the following sub-derivation:

If expr_single Then expr option(else_expr) 
                    expr_single 
                    If expr_single Then expr option(else_expr) 
                                             else_expr 
                                             . Else expr 

** In state 147, looking ahead at Else, reducing production
** option(else_expr) -> 
** is permitted because of the following sub-derivation:

If expr_single Then expr option(else_expr) // lookahead token appears because option(else_expr) can begin with Else
                    expr_single // lookahead token is inherited
                    If expr_single Then expr option(else_expr) // lookahead token is inherited
                                             . 

** Conflict (shift/reduce) in state 140.
** Token involved: RB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Iden expr_single LB2 expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             Iden nonempty_list(expr_single) 
                                                  (?)

** In state 140, looking ahead at RB2, shifting is permitted
** because of the following sub-derivation:

expr_single 
expr_single LB2 expr_single . RB2 

** In state 140, looking ahead at RB2, reducing production
** expr_single_list -> expr_single 
** is permitted because of the following sub-derivation:

expr_single nonempty_list(expr_single) 
            expr_single 
            LB2 expr_single_list RB2 // lookahead token appears
                expr_single . 

** Conflict (shift/reduce/reduce) in state 136.
** Tokens involved: With While Vertical Var Val UIden True Then Semicolon RB3 RB2 RB1 Oro Or Non_Equal Negb Model Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE For Float False Equal Else EOF DotDot Done Do Comma Ando And AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Iden expr_single Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 136, looking ahead at With, reducing production
** expr_single -> Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single nonempty_list(expr_single) // lookahead token is inherited
                 expr_single // lookahead token is inherited
                 Minus expr_single . 

** In state 136, looking ahead at With, reducing production
** expr_single -> expr_single Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single // lookahead token is inherited
     expr_single Minus expr_single . 

** In state 136, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single Minus expr_single 
                       expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce/reduce) in state 134.
** Tokens involved: With While Vertical Var Val UIden True Then Semicolon RB3 RB2 RB1 Oro Or Non_Equal Negb Model Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE For Float False Equal Else EOF DotDot Done Do Comma Ando And AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Iden expr_single MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 134, looking ahead at With, reducing production
** expr_single -> MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single nonempty_list(expr_single) // lookahead token is inherited
                 expr_single // lookahead token is inherited
                 MinusDot expr_single . 

** In state 134, looking ahead at With, reducing production
** expr_single -> expr_single MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single // lookahead token is inherited
     expr_single MinusDot expr_single . 

** In state 134, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single MinusDot expr_single 
                          expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 132.
** Tokens involved: With While Var Val UIden True Oro Non_Equal Negb MultDot Mult MinusDot Minus Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE For Float False Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Iden expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 132, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single . With LB3 str_expr_list RB3 

** In state 132, looking ahead at With, reducing production
** nonempty_list(expr_single) -> expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single . 

** Conflict (shift/reduce) in state 130.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Iden Dot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 130, looking ahead at With, reducing production
** expr_single -> Iden Dot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden Dot expr_single . 

** In state 130, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden Dot expr_single 
         expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 120.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Ando expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 120, looking ahead at LB2, reducing production
** expr_single -> expr_single Ando expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Ando expr_single . 

** In state 120, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Ando expr_single 
                 expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 118.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single GE expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 118, looking ahead at LB2, reducing production
** expr_single -> expr_single GE expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single GE expr_single . 

** In state 118, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single GE expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 116.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single GT expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 116, looking ahead at LB2, reducing production
** expr_single -> expr_single GT expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single GT expr_single . 

** In state 116, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single GT expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 114.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single LArrow expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 114, looking ahead at LB2, reducing production
** expr_single -> expr_single LArrow expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single LArrow expr_single . 

** In state 114, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single LArrow expr_single 
                   expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 112.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single LE expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 112, looking ahead at LB2, reducing production
** expr_single -> expr_single LE expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single LE expr_single . 

** In state 112, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single LE expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 110.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Add expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 110, looking ahead at LB2, reducing production
** expr_single -> expr_single Add expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Add expr_single . 

** In state 110, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Add expr_single 
                expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 108.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single AddDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 108, looking ahead at LB2, reducing production
** expr_single -> expr_single AddDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single AddDot expr_single . 

** In state 108, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single AddDot expr_single 
                   expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 106.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 106, looking ahead at LB2, reducing production
** expr_single -> expr_single Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Equal expr_single . 

** In state 106, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Equal expr_single 
                  expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 104.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single LT expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 104, looking ahead at LB2, reducing production
** expr_single -> expr_single LT expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single LT expr_single . 

** In state 104, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single LT expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 102.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 102, looking ahead at LB2, reducing production
** expr_single -> expr_single Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Minus expr_single . 

** In state 102, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Minus expr_single 
                  expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 100.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 100, looking ahead at LB2, reducing production
** expr_single -> expr_single MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single MinusDot expr_single . 

** In state 100, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single MinusDot expr_single 
                     expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 98.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Mult expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 98, looking ahead at LB2, reducing production
** expr_single -> expr_single Mult expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Mult expr_single . 

** In state 98, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Mult expr_single 
                 expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 93.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single MultDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 93, looking ahead at LB2, reducing production
** expr_single -> expr_single MultDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single MultDot expr_single . 

** In state 93, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single MultDot expr_single 
                    expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 91.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Non_Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 91, looking ahead at LB2, reducing production
** expr_single -> expr_single Non_Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Non_Equal expr_single . 

** In state 91, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Non_Equal expr_single 
                      expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 89.
** Token involved: LB2
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single Oro expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 89, looking ahead at LB2, reducing production
** expr_single -> expr_single Oro expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Oro expr_single . 

** In state 89, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Oro expr_single 
                expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 85.
** Tokens involved: With Semicolon Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token Semicolon.
** This state is reached from program after reading:

imported declars Model LB3 Init Equal expr_single Semicolon expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars kripke EOF 
                 (?)

** In state 85, looking ahead at Semicolon, reducing production
** separated_nonempty_list(Semicolon,expr_single) -> expr_single 
** is permitted because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 // lookahead token appears
                     expr_single Semicolon separated_nonempty_list(Semicolon,expr_single) // lookahead token is inherited
                                           expr_single . 

** In state 85, looking ahead at Semicolon, shifting is permitted
** because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 
                     expr_single Semicolon separated_nonempty_list(Semicolon,expr_single) 
                                           expr_single . Semicolon separated_nonempty_list(Semicolon,expr_single) 

** Conflict (shift/reduce) in state 82.
** Tokens involved: With Semicolon Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token Semicolon.
** This state is reached from program after reading:

imported declars Model LB3 Init Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars kripke EOF 
                 (?)

** In state 82, looking ahead at Semicolon, reducing production
** expr -> expr_single 
** is permitted because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 // lookahead token appears
                     expr_single . 

** In state 82, looking ahead at Semicolon, shifting is permitted
** because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 
                     expr_single . Semicolon separated_nonempty_list(Semicolon,expr_single) 

** Conflict (shift/reduce) in state 77.
** Token involved: Iden
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal expr_single With LB3 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             expr_single With LB3 str_expr_list RB3 
                                                                  (?)

** In state 77, looking ahead at Iden, reducing production
** str_expr_list -> 
** is permitted because of the following sub-derivation:

str_expr_list Iden Equal expr Semicolon // lookahead token appears
. 

** In state 77, looking ahead at Iden, shifting is permitted
** because of the following sub-derivation:

. Iden Equal expr Semicolon 

** Conflict (shift/reduce) in state 68.
** Tokens involved: While Var Val UIden True Negb MinusDot Minus Match LB3 LB2 LB1 Int If Iden For Float False
** The following explanations concentrate on token MinusDot.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal Iden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 68, looking ahead at MinusDot, reducing production
** expr_single -> Iden 
** is permitted because of the following sub-derivation:

expr_single MinusDot expr_single // lookahead token appears
Iden . 

** In state 68, looking ahead at MinusDot, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     . MinusDot expr_single 

** Conflict (shift/reduce) in state 59.
** Token involved: Iden
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal LB3 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             LB3 str_expr_list RB3 
                                                 (?)

** In state 59, looking ahead at Iden, reducing production
** str_expr_list -> 
** is permitted because of the following sub-derivation:

str_expr_list Iden Equal expr Semicolon // lookahead token appears
. 

** In state 59, looking ahead at Iden, shifting is permitted
** because of the following sub-derivation:

. Iden Equal expr Semicolon 

** Conflict (shift/reduce) in state 53.
** Tokens involved: While Var Val UIden True Negb MinusDot Minus Match LB3 LB2 LB1 Int If Iden For Float False
** The following explanations concentrate on token MinusDot.
** This state is reached from program after reading:

imported Var Iden option(type_of_expr) Equal UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                                             (?)

** In state 53, looking ahead at MinusDot, shifting is permitted
** because of the following sub-derivation:

UIden expr_single 
      . MinusDot expr_single 

** In state 53, looking ahead at MinusDot, reducing production
** expr_single -> UIden 
** is permitted because of the following sub-derivation:

expr_single MinusDot expr_single // lookahead token appears
UIden . 

** Conflict (shift/reduce) in state 41.
** Tokens involved: TLst TAray Arrow
** The following explanations concentrate on token TLst.
** This state is reached from program after reading:

imported Var Iden Colon UIden typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                  type_of_expr 
                  Colon typ 
                        (?)

** In state 41, looking ahead at TLst, reducing production
** constr -> UIden typ 
** is permitted because of the following sub-derivation:

typ TLst // lookahead token appears
constrs // lookahead token is inherited
nonempty_list(constr) // lookahead token is inherited
constr // lookahead token is inherited
UIden typ . 

** In state 41, looking ahead at TLst, shifting is permitted
** because of the following sub-derivation:

constrs 
nonempty_list(constr) 
constr 
UIden typ 
      typ . TLst 

** Conflict (shift/reduce) in state 24.
** Token involved: UIden
** This state is reached from program after reading:

imported Var Iden Colon UIden constr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                  type_of_expr 
                  Colon typ 
                        constrs 
                        nonempty_list(constr) 
                        (?)

** In state 24, looking ahead at UIden, shifting is permitted
** because of the following sub-derivation:

constr 
UIden typ 
      constrs 
      nonempty_list(constr) 
      constr nonempty_list(constr) 
             constr 
             . UIden 

** In state 24, looking ahead at UIden, reducing production
** nonempty_list(constr) -> constr 
** is permitted because of the following sub-derivation:

constr nonempty_list(constr) // lookahead token appears because nonempty_list(constr) can begin with UIden
UIden typ // lookahead token is inherited
      constrs // lookahead token is inherited
      nonempty_list(constr) // lookahead token is inherited
      constr . 

** Conflict (shift/reduce) in state 20.
** Tokens involved: TLst TAray
** The following explanations concentrate on token TLst.
** This state is reached from program after reading:

imported Var Iden Colon typ Arrow typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                  type_of_expr 
                  Colon typ 
                        (?)

** In state 20, looking ahead at TLst, shifting is permitted
** because of the following sub-derivation:

typ Arrow typ 
          typ . TLst 

** In state 20, looking ahead at TLst, reducing production
** typ -> typ Arrow typ 
** is permitted because of the following sub-derivation:

typ TLst // lookahead token appears
typ Arrow typ . 

** Conflict (shift/reduce) in state 16.
** Tokens involved: UIden TUnt TLst TInt TFloat TBool TAray LB3 LB1 Iden Arrow
** The following explanations concentrate on token TLst.
** This state is reached from program after reading:

imported Var Iden Colon Iden typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                  type_of_expr 
                  Colon typ 
                        (?)

** In state 16, looking ahead at TLst, reducing production
** list(typ) -> 
** is permitted because of the following sub-derivation:

typ TLst // lookahead token appears
Iden list(typ) // lookahead token is inherited
     typ list(typ) // lookahead token is inherited
         . 

** In state 16, looking ahead at TLst, shifting is permitted
** because of the following sub-derivation:

Iden list(typ) 
     typ list(typ) 
     typ . TLst 

** Conflict (shift/reduce) in state 15.
** Tokens involved: UIden TUnt TInt TFloat TBool LB3 LB1 Iden
** The following explanations concentrate on token UIden.
** This state is reached from program after reading:

imported Var Iden Colon UIden Iden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                  type_of_expr 
                  Colon typ 
                        constrs 
                        nonempty_list(constr) 
                        (?)

** In state 15, looking ahead at UIden, shifting is permitted
** because of the following sub-derivation:

constr 
UIden typ 
      Iden list(typ) 
           typ list(typ) 
           constrs 
           nonempty_list(constr) 
           constr 
           . UIden 

** In state 15, looking ahead at UIden, reducing production
** list(typ) -> 
** is permitted because of the following sub-derivation:

constr nonempty_list(constr) // lookahead token appears because nonempty_list(constr) can begin with UIden
UIden typ // lookahead token is inherited
      Iden list(typ) // lookahead token is inherited
           . 

** Conflict (shift/reduce) in state 6.
** Tokens involved: UIden TUnt TInt TFloat TBool LB3 LB1 Iden
** The following explanations concentrate on token UIden.
** This state is reached from program after reading:

imported Var Iden Colon UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         Var Iden option(type_of_expr) Equal expr_single 
                  type_of_expr 
                  Colon typ 
                        constrs 
                        nonempty_list(constr) 
                        (?)

** In state 6, looking ahead at UIden, shifting is permitted
** because of the following sub-derivation:

constr 
UIden typ 
      constrs 
      nonempty_list(constr) 
      constr 
      . UIden 

** In state 6, looking ahead at UIden, reducing production
** constr -> UIden 
** is permitted because of the following sub-derivation:

constr nonempty_list(constr) // lookahead token appears because nonempty_list(constr) can begin with UIden
UIden . 
