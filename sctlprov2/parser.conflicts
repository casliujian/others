
** Conflict (shift/reduce) in state 212.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Var Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 212, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Var Iden Equal expr_single 
               expr_single . With LB3 str_expr_list RB3 

** In state 212, looking ahead at With, reducing production
** expr_single -> Var Iden Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Var Iden Equal expr_single . 

** Conflict (shift/reduce) in state 211.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Val Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 211, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Val Iden Equal expr_single 
               expr_single . With LB3 str_expr_list RB3 

** In state 211, looking ahead at With, reducing production
** expr_single -> Val Iden Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Val Iden Equal expr_single . 

** Conflict (shift/reduce) in state 210.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal ColonColon Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal UIden expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 210, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

UIden expr_single 
      expr_single . With LB3 str_expr_list RB3 

** In state 210, looking ahead at With, reducing production
** expr_single -> UIden expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
UIden expr_single . 

** Conflict (shift/reduce) in state 207.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Negb expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 207, looking ahead at With, reducing production
** expr_single -> Negb expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Negb expr_single . 

** In state 207, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Negb expr_single 
     expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 206.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 206, looking ahead at With, reducing production
** expr_single -> MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
MinusDot expr_single . 

** In state 206, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

MinusDot expr_single 
         expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 205.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 205, looking ahead at With, reducing production
** expr_single -> Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Minus expr_single . 

** In state 205, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Minus expr_single 
      expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 198.
** Token involved: ColonColon
** This state is reached from debug after reading:

Function Iden UIden pattern 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Function Iden args option(type_of_expr) Equal expr 
              pattern 
              (?)

** In state 198, looking ahead at ColonColon, shifting is permitted
** because of the following sub-derivation:

UIden pattern 
      pattern . ColonColon pattern 

** In state 198, looking ahead at ColonColon, reducing production
** pattern -> UIden pattern 
** is permitted because of the following sub-derivation:

pattern ColonColon pattern // lookahead token appears
UIden pattern . 

** Conflict (shift/reduce) in state 172.
** Tokens involved: Underline UIden LB2 LB1 Int Iden Float
** The following explanations concentrate on token Underline.
** This state is reached from debug after reading:

Function Iden UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Function Iden args option(type_of_expr) Equal expr 
              (?)

** In state 172, looking ahead at Underline, shifting is permitted
** because of the following sub-derivation:

pattern 
UIden pattern 
      . Underline 

** In state 172, looking ahead at Underline, reducing production
** pattern -> UIden 
** is permitted because of the following sub-derivation:

pattern args // lookahead token appears because args can begin with Underline
UIden . 

** Conflict (shift/reduce) in state 169.
** Token involved: Vertical
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal LB2 Vertical Match expr_single With pattern_expr_list 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 169, looking ahead at Vertical, reducing production
** expr_single -> Match expr_single With pattern_expr_list 
** is permitted because of the following sub-derivation:

LB2 Vertical expr_single_list Vertical RB2 // lookahead token appears
             expr_single // lookahead token is inherited
             Match expr_single With pattern_expr_list . 

** In state 169, looking ahead at Vertical, shifting is permitted
** because of the following sub-derivation:

LB2 Vertical expr_single_list Vertical RB2 
             expr_single 
             Match expr_single With pattern_expr_list 
                                    pattern_expr_list . Vertical pattern_expr 

** Conflict (shift/reduce) in state 145.
** Token involved: Else
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal If expr_single Then If expr_single Then expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 145, looking ahead at Else, shifting is permitted
** because of the following sub-derivation:

If expr_single Then expr option(else_expr) 
                    expr_single 
                    If expr_single Then expr option(else_expr) 
                                             else_expr 
                                             . Else expr 

** In state 145, looking ahead at Else, reducing production
** option(else_expr) -> 
** is permitted because of the following sub-derivation:

If expr_single Then expr option(else_expr) // lookahead token appears because option(else_expr) can begin with Else
                    expr_single // lookahead token is inherited
                    If expr_single Then expr option(else_expr) // lookahead token is inherited
                                             . 

** Conflict (shift/reduce) in state 138.
** Token involved: RB2
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Iden expr_single LB2 expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    Iden nonempty_list(expr_single) 
                                         (?)

** In state 138, looking ahead at RB2, shifting is permitted
** because of the following sub-derivation:

expr_single 
expr_single LB2 expr_single . RB2 

** In state 138, looking ahead at RB2, reducing production
** expr_single_list -> expr_single 
** is permitted because of the following sub-derivation:

expr_single nonempty_list(expr_single) 
            expr_single 
            LB2 expr_single_list RB2 // lookahead token appears
                expr_single . 

** Conflict (shift/reduce/reduce) in state 134.
** Tokens involved: With While Vertical Var Val UIden True Transition Top Then State Semicolon RB3 RB2 RB1 Property Oro Or Non_Equal Negb Neg MultDot Mult Model MinusDot Minus Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE Function For Float False Equal Else EX EU EOF EG DotDot Done Do Datatype Comma ColonColon Bottom Ando And AddDot Add AX AR AF
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Iden expr_single Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 134, looking ahead at With, reducing production
** expr_single -> Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single nonempty_list(expr_single) // lookahead token is inherited
                 expr_single // lookahead token is inherited
                 Minus expr_single . 

** In state 134, looking ahead at With, reducing production
** expr_single -> expr_single Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single // lookahead token is inherited
     expr_single Minus expr_single . 

** In state 134, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single Minus expr_single 
                       expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce/reduce) in state 132.
** Tokens involved: With While Vertical Var Val UIden True Transition Top Then State Semicolon RB3 RB2 RB1 Property Oro Or Non_Equal Negb Neg MultDot Mult Model MinusDot Minus Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE Function For Float False Equal Else EX EU EOF EG DotDot Done Do Datatype Comma ColonColon Bottom Ando And AddDot Add AX AR AF
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Iden expr_single MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 132, looking ahead at With, reducing production
** expr_single -> MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single nonempty_list(expr_single) // lookahead token is inherited
                 expr_single // lookahead token is inherited
                 MinusDot expr_single . 

** In state 132, looking ahead at With, reducing production
** expr_single -> expr_single MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single // lookahead token is inherited
     expr_single MinusDot expr_single . 

** In state 132, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single MinusDot expr_single 
                          expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 130.
** Tokens involved: With While Var Val UIden True Oro Non_Equal Negb MultDot Mult MinusDot Minus Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE For Float False Equal ColonColon Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Iden expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 130, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single . With LB3 str_expr_list RB3 

** In state 130, looking ahead at With, reducing production
** nonempty_list(expr_single) -> expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single . 

** Conflict (shift/reduce) in state 117.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Ando expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 117, looking ahead at With, reducing production
** expr_single -> expr_single Ando expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Ando expr_single . 

** In state 117, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Ando expr_single 
                 expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 115.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single ColonColon expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 115, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single ColonColon expr_single 
                       expr_single . With LB3 str_expr_list RB3 

** In state 115, looking ahead at With, reducing production
** expr_single -> expr_single ColonColon expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single ColonColon expr_single . 

** Conflict (shift/reduce) in state 113.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single GE expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 113, looking ahead at With, reducing production
** expr_single -> expr_single GE expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single GE expr_single . 

** In state 113, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single GE expr_single 
               expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 111.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single GT expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 111, looking ahead at With, reducing production
** expr_single -> expr_single GT expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single GT expr_single . 

** In state 111, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single GT expr_single 
               expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 109.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single LE expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 109, looking ahead at With, reducing production
** expr_single -> expr_single LE expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single LE expr_single . 

** In state 109, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single LE expr_single 
               expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 107.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Add expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 107, looking ahead at With, reducing production
** expr_single -> expr_single Add expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Add expr_single . 

** In state 107, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Add expr_single 
                expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 105.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single AddDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 105, looking ahead at With, reducing production
** expr_single -> expr_single AddDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single AddDot expr_single . 

** In state 105, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single AddDot expr_single 
                   expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 103.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 103, looking ahead at With, reducing production
** expr_single -> expr_single Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Equal expr_single . 

** In state 103, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Equal expr_single 
                  expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 101.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single LT expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 101, looking ahead at With, reducing production
** expr_single -> expr_single LT expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single LT expr_single . 

** In state 101, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single LT expr_single 
               expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 99.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 99, looking ahead at With, reducing production
** expr_single -> expr_single Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Minus expr_single . 

** In state 99, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Minus expr_single 
                  expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 97.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 97, looking ahead at With, reducing production
** expr_single -> expr_single MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single MinusDot expr_single . 

** In state 97, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single MinusDot expr_single 
                     expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 95.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal ColonColon Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single LArrow expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 95, looking ahead at With, reducing production
** expr_single -> expr_single LArrow expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single LArrow expr_single . 

** In state 95, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single LArrow expr_single 
                   expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 93.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Mult expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 93, looking ahead at With, reducing production
** expr_single -> expr_single Mult expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Mult expr_single . 

** In state 93, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Mult expr_single 
                 expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 88.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single MultDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 88, looking ahead at With, reducing production
** expr_single -> expr_single MultDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single MultDot expr_single . 

** In state 88, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single MultDot expr_single 
                    expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 86.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Non_Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 86, looking ahead at With, reducing production
** expr_single -> expr_single Non_Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Non_Equal expr_single . 

** In state 86, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Non_Equal expr_single 
                      expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 84.
** Tokens involved: With LB2 LArrow
** The following explanations concentrate on token With.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single Oro expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 84, looking ahead at With, reducing production
** expr_single -> expr_single Oro expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
expr_single Oro expr_single . 

** In state 84, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

expr_single Oro expr_single 
                expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 79.
** Tokens involved: With Semicolon Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal ColonColon Ando AddDot Add
** The following explanations concentrate on token Semicolon.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal LB3 Iden Equal expr_single Semicolon expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    LB3 str_expr_list RB3 
                                        (?)

** In state 79, looking ahead at Semicolon, reducing production
** separated_nonempty_list(Semicolon,expr_single) -> expr_single 
** is permitted because of the following sub-derivation:

Iden Equal expr Semicolon // lookahead token appears
           expr_single Semicolon separated_nonempty_list(Semicolon,expr_single) // lookahead token is inherited
                                 expr_single . 

** In state 79, looking ahead at Semicolon, shifting is permitted
** because of the following sub-derivation:

Iden Equal expr Semicolon 
           expr_single Semicolon separated_nonempty_list(Semicolon,expr_single) 
                                 expr_single . Semicolon separated_nonempty_list(Semicolon,expr_single) 

** Conflict (shift/reduce) in state 76.
** Tokens involved: With Semicolon Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal ColonColon Ando AddDot Add
** The following explanations concentrate on token Semicolon.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal LB3 Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    LB3 str_expr_list RB3 
                                        (?)

** In state 76, looking ahead at Semicolon, reducing production
** expr -> expr_single 
** is permitted because of the following sub-derivation:

Iden Equal expr Semicolon // lookahead token appears
           expr_single . 

** In state 76, looking ahead at Semicolon, shifting is permitted
** because of the following sub-derivation:

Iden Equal expr Semicolon 
           expr_single . Semicolon separated_nonempty_list(Semicolon,expr_single) 

** Conflict (shift/reduce) in state 71.
** Token involved: Iden
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal expr_single With LB3 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    expr_single With LB3 str_expr_list RB3 
                                                         (?)

** In state 71, looking ahead at Iden, reducing production
** str_expr_list -> 
** is permitted because of the following sub-derivation:

str_expr_list Iden Equal expr Semicolon // lookahead token appears
. 

** In state 71, looking ahead at Iden, shifting is permitted
** because of the following sub-derivation:

. Iden Equal expr Semicolon 

** Conflict (shift/reduce) in state 62.
** Tokens involved: While Var Val UIden True Negb MinusDot Minus Match LB3 LB2 LB1 Int If Iden For Float False
** The following explanations concentrate on token MinusDot.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal Iden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 62, looking ahead at MinusDot, reducing production
** expr_path -> Iden 
** is permitted because of the following sub-derivation:

expr_single MinusDot expr_single // lookahead token appears
expr_path // lookahead token is inherited
Iden . 

** In state 62, looking ahead at MinusDot, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     . MinusDot expr_single 

** Conflict (shift/reduce) in state 53.
** Token involved: Iden
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal LB3 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    LB3 str_expr_list RB3 
                                        (?)

** In state 53, looking ahead at Iden, reducing production
** str_expr_list -> 
** is permitted because of the following sub-derivation:

str_expr_list Iden Equal expr Semicolon // lookahead token appears
. 

** In state 53, looking ahead at Iden, shifting is permitted
** because of the following sub-derivation:

. Iden Equal expr Semicolon 

** Conflict (shift/reduce) in state 47.
** Tokens involved: While Var Val UIden True Negb MinusDot Minus Match LB3 LB2 LB1 Int If Iden For Float False
** The following explanations concentrate on token MinusDot.
** This state is reached from debug after reading:

Var Iden option(type_of_expr) Equal UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
                                    (?)

** In state 47, looking ahead at MinusDot, shifting is permitted
** because of the following sub-derivation:

UIden expr_single 
      . MinusDot expr_single 

** In state 47, looking ahead at MinusDot, reducing production
** expr_single -> UIden 
** is permitted because of the following sub-derivation:

expr_single MinusDot expr_single // lookahead token appears
UIden . 

** Conflict (shift/reduce) in state 35.
** Token involved: Arrow
** This state is reached from debug after reading:

Var Iden Colon TLst typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
         type_of_expr 
         Colon typ 
               (?)

** In state 35, looking ahead at Arrow, reducing production
** typ -> TLst typ 
** is permitted because of the following sub-derivation:

typ Arrow typ // lookahead token appears
TLst typ . 

** In state 35, looking ahead at Arrow, shifting is permitted
** because of the following sub-derivation:

TLst typ 
     typ . Arrow typ 

** Conflict (shift/reduce) in state 34.
** Token involved: Arrow
** This state is reached from debug after reading:

Var Iden Colon TAray typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
         type_of_expr 
         Colon typ 
               (?)

** In state 34, looking ahead at Arrow, reducing production
** typ -> TAray typ 
** is permitted because of the following sub-derivation:

typ Arrow typ // lookahead token appears
TAray typ . 

** In state 34, looking ahead at Arrow, shifting is permitted
** because of the following sub-derivation:

TAray typ 
      typ . Arrow typ 

** Conflict (shift/reduce) in state 15.
** Tokens involved: TUnt TLst TInt TFloat TBool TAray LB3 LB1 Iden Arrow
** The following explanations concentrate on token Arrow.
** This state is reached from debug after reading:

Var Iden Colon Iden typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
         type_of_expr 
         Colon typ 
               (?)

** In state 15, looking ahead at Arrow, reducing production
** list(typ) -> 
** is permitted because of the following sub-derivation:

typ Arrow typ // lookahead token appears
Iden list(typ) // lookahead token is inherited
     typ list(typ) // lookahead token is inherited
         . 

** In state 15, looking ahead at Arrow, shifting is permitted
** because of the following sub-derivation:

Iden list(typ) 
     typ list(typ) 
     typ . Arrow typ 

** Conflict (shift/reduce) in state 14.
** Tokens involved: TUnt TLst TInt TFloat TBool TAray LB3 LB1 Iden
** The following explanations concentrate on token TUnt.
** This state is reached from debug after reading:

Var Iden Colon Iden Iden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

debug 
declare EOF 
Var Iden option(type_of_expr) Equal expr_single 
         type_of_expr 
         Colon typ 
               Iden list(typ) 
                    (?)

** In state 14, looking ahead at TUnt, reducing production
** list(typ) -> 
** is permitted because of the following sub-derivation:

typ list(typ) // lookahead token appears because list(typ) can begin with TUnt
Iden list(typ) // lookahead token is inherited
     . 

** In state 14, looking ahead at TUnt, shifting is permitted
** because of the following sub-derivation:

typ list(typ) 
Iden list(typ) 
     typ list(typ) 
     . TUnt 
