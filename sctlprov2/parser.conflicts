
** Conflict (shift/reduce) in state 217.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Var Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 217, looking ahead at LB2, reducing production
** expr_single -> Var Iden Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Var Iden Equal expr_single . 

** In state 217, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Var Iden Equal expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 216.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Val Iden Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 216, looking ahead at LB2, reducing production
** expr_single -> Val Iden Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Val Iden Equal expr_single . 

** In state 216, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Val Iden Equal expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 215.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal UIden expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 215, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

UIden expr_single 
      expr_single . With LB3 str_expr_list RB3 

** In state 215, looking ahead at With, reducing production
** expr_single -> UIden expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
UIden expr_single . 

** Conflict (shift/reduce) in state 214.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal UIden Dot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 214, looking ahead at With, reducing production
** expr_single -> UIden Dot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
UIden Dot expr_single . 

** In state 214, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

UIden Dot expr_single 
          expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 212.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Negb expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 212, looking ahead at LB2, reducing production
** expr_single -> Negb expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Negb expr_single . 

** In state 212, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Negb expr_single 
     expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 211.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 211, looking ahead at LB2, reducing production
** expr_single -> MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
MinusDot expr_single . 

** In state 211, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

MinusDot expr_single 
         expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 210.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 210, looking ahead at LB2, reducing production
** expr_single -> Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
Minus expr_single . 

** In state 210, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

Minus expr_single 
      expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 203.
** Token involved: ColonColon
** This state is reached from program after reading:

imported declars Function Iden UIden pattern 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Function Iden args option(type_of_expr) Equal expr 
                               pattern 
                               (?)

** In state 203, looking ahead at ColonColon, shifting is permitted
** because of the following sub-derivation:

UIden pattern 
      pattern . ColonColon pattern 

** In state 203, looking ahead at ColonColon, reducing production
** pattern -> UIden pattern 
** is permitted because of the following sub-derivation:

pattern ColonColon pattern // lookahead token appears
UIden pattern . 

** Conflict (shift/reduce) in state 177.
** Tokens involved: Underline UIden LB2 LB1 Int Iden Float
** The following explanations concentrate on token Underline.
** This state is reached from program after reading:

imported declars Function Iden UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Function Iden args option(type_of_expr) Equal expr 
                               (?)

** In state 177, looking ahead at Underline, shifting is permitted
** because of the following sub-derivation:

pattern 
UIden pattern 
      . Underline 

** In state 177, looking ahead at Underline, reducing production
** pattern -> UIden 
** is permitted because of the following sub-derivation:

pattern args // lookahead token appears because args can begin with Underline
UIden . 

** Conflict (shift/reduce) in state 174.
** Token involved: Vertical
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal LB2 Vertical Match expr_single With pattern_expr_list 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 174, looking ahead at Vertical, reducing production
** expr_single -> Match expr_single With pattern_expr_list 
** is permitted because of the following sub-derivation:

LB2 Vertical expr_single_list Vertical RB2 // lookahead token appears
             expr_single // lookahead token is inherited
             Match expr_single With pattern_expr_list . 

** In state 174, looking ahead at Vertical, shifting is permitted
** because of the following sub-derivation:

LB2 Vertical expr_single_list Vertical RB2 
             expr_single 
             Match expr_single With pattern_expr_list 
                                    pattern_expr_list . Vertical pattern_expr 

** Conflict (shift/reduce) in state 150.
** Token involved: Else
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal If expr_single Then If expr_single Then expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 150, looking ahead at Else, shifting is permitted
** because of the following sub-derivation:

If expr_single Then expr option(else_expr) 
                    expr_single 
                    If expr_single Then expr option(else_expr) 
                                             else_expr 
                                             . Else expr 

** In state 150, looking ahead at Else, reducing production
** option(else_expr) -> 
** is permitted because of the following sub-derivation:

If expr_single Then expr option(else_expr) // lookahead token appears because option(else_expr) can begin with Else
                    expr_single // lookahead token is inherited
                    If expr_single Then expr option(else_expr) // lookahead token is inherited
                                             . 

** Conflict (shift/reduce) in state 143.
** Token involved: RB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Iden expr_single LB2 expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     Iden nonempty_list(expr_single) 
                                                          (?)

** In state 143, looking ahead at RB2, shifting is permitted
** because of the following sub-derivation:

expr_single 
expr_single LB2 expr_single . RB2 

** In state 143, looking ahead at RB2, reducing production
** expr_single_list -> expr_single 
** is permitted because of the following sub-derivation:

expr_single nonempty_list(expr_single) 
            expr_single 
            LB2 expr_single_list RB2 // lookahead token appears
                expr_single . 

** Conflict (shift/reduce/reduce) in state 139.
** Tokens involved: With While Vertical Var Val UIden True Then Semicolon RB3 RB2 RB1 Oro Or Non_Equal Negb Model Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE Function For Float False Equal Else EOF DotDot Done Do Datatype Comma Ando And AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Iden expr_single Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 139, looking ahead at With, reducing production
** expr_single -> Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single nonempty_list(expr_single) // lookahead token is inherited
                 expr_single // lookahead token is inherited
                 Minus expr_single . 

** In state 139, looking ahead at With, reducing production
** expr_single -> expr_single Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single // lookahead token is inherited
     expr_single Minus expr_single . 

** In state 139, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single Minus expr_single 
                       expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce/reduce) in state 137.
** Tokens involved: With While Vertical Var Val UIden True Then Semicolon RB3 RB2 RB1 Oro Or Non_Equal Negb Model Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE Function For Float False Equal Else EOF DotDot Done Do Datatype Comma Ando And AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Iden expr_single MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 137, looking ahead at With, reducing production
** expr_single -> MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single nonempty_list(expr_single) // lookahead token is inherited
                 expr_single // lookahead token is inherited
                 MinusDot expr_single . 

** In state 137, looking ahead at With, reducing production
** expr_single -> expr_single MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single // lookahead token is inherited
     expr_single MinusDot expr_single . 

** In state 137, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single MinusDot expr_single 
                          expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 135.
** Tokens involved: With While Var Val UIden True Oro Non_Equal Negb MultDot Mult MinusDot Minus Match LT LE LB3 LB2 LB1 LArrow Int If Iden GT GE For Float False Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Iden expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 135, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden nonempty_list(expr_single) 
     expr_single 
     expr_single . With LB3 str_expr_list RB3 

** In state 135, looking ahead at With, reducing production
** nonempty_list(expr_single) -> expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden nonempty_list(expr_single) // lookahead token is inherited
     expr_single . 

** Conflict (shift/reduce) in state 133.
** Tokens involved: With Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token With.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Iden Dot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 133, looking ahead at With, reducing production
** expr_single -> Iden Dot expr_single 
** is permitted because of the following sub-derivation:

expr_single With LB3 str_expr_list RB3 // lookahead token appears
Iden Dot expr_single . 

** In state 133, looking ahead at With, shifting is permitted
** because of the following sub-derivation:

Iden Dot expr_single 
         expr_single . With LB3 str_expr_list RB3 

** Conflict (shift/reduce) in state 123.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Ando expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 123, looking ahead at LB2, reducing production
** expr_single -> expr_single Ando expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Ando expr_single . 

** In state 123, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Ando expr_single 
                 expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 121.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single GE expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 121, looking ahead at LB2, reducing production
** expr_single -> expr_single GE expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single GE expr_single . 

** In state 121, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single GE expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 119.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single GT expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 119, looking ahead at LB2, reducing production
** expr_single -> expr_single GT expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single GT expr_single . 

** In state 119, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single GT expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 117.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single LArrow expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 117, looking ahead at LB2, reducing production
** expr_single -> expr_single LArrow expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single LArrow expr_single . 

** In state 117, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single LArrow expr_single 
                   expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 115.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single LE expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 115, looking ahead at LB2, reducing production
** expr_single -> expr_single LE expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single LE expr_single . 

** In state 115, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single LE expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 113.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Add expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 113, looking ahead at LB2, reducing production
** expr_single -> expr_single Add expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Add expr_single . 

** In state 113, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Add expr_single 
                expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 111.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single AddDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 111, looking ahead at LB2, reducing production
** expr_single -> expr_single AddDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single AddDot expr_single . 

** In state 111, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single AddDot expr_single 
                   expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 109.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 109, looking ahead at LB2, reducing production
** expr_single -> expr_single Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Equal expr_single . 

** In state 109, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Equal expr_single 
                  expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 107.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single LT expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 107, looking ahead at LB2, reducing production
** expr_single -> expr_single LT expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single LT expr_single . 

** In state 107, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single LT expr_single 
               expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 105.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Minus expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 105, looking ahead at LB2, reducing production
** expr_single -> expr_single Minus expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Minus expr_single . 

** In state 105, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Minus expr_single 
                  expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 103.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single MinusDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 103, looking ahead at LB2, reducing production
** expr_single -> expr_single MinusDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single MinusDot expr_single . 

** In state 103, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single MinusDot expr_single 
                     expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 101.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Mult expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 101, looking ahead at LB2, reducing production
** expr_single -> expr_single Mult expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Mult expr_single . 

** In state 101, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Mult expr_single 
                 expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 96.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single MultDot expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 96, looking ahead at LB2, reducing production
** expr_single -> expr_single MultDot expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single MultDot expr_single . 

** In state 96, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single MultDot expr_single 
                    expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 94.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Non_Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 94, looking ahead at LB2, reducing production
** expr_single -> expr_single Non_Equal expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Non_Equal expr_single . 

** In state 94, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Non_Equal expr_single 
                      expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 92.
** Token involved: LB2
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single Oro expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     (?)

** In state 92, looking ahead at LB2, reducing production
** expr_single -> expr_single Oro expr_single 
** is permitted because of the following sub-derivation:

expr_single LB2 expr_single RB2 // lookahead token appears
expr_single Oro expr_single . 

** In state 92, looking ahead at LB2, shifting is permitted
** because of the following sub-derivation:

expr_single Oro expr_single 
                expr_single . LB2 expr_single RB2 

** Conflict (shift/reduce) in state 88.
** Tokens involved: With Semicolon Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token Semicolon.
** This state is reached from program after reading:

imported declars Model LB3 Init Equal expr_single Semicolon expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars kripke EOF 
                 (?)

** In state 88, looking ahead at Semicolon, reducing production
** separated_nonempty_list(Semicolon,expr_single) -> expr_single 
** is permitted because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 // lookahead token appears
                     expr_single Semicolon separated_nonempty_list(Semicolon,expr_single) // lookahead token is inherited
                                           expr_single . 

** In state 88, looking ahead at Semicolon, shifting is permitted
** because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 
                     expr_single Semicolon separated_nonempty_list(Semicolon,expr_single) 
                                           expr_single . Semicolon separated_nonempty_list(Semicolon,expr_single) 

** Conflict (shift/reduce) in state 85.
** Tokens involved: With Semicolon Oro Non_Equal MultDot Mult MinusDot Minus LT LE LB2 LArrow GT GE Equal Ando AddDot Add
** The following explanations concentrate on token Semicolon.
** This state is reached from program after reading:

imported declars Model LB3 Init Equal expr_single 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars kripke EOF 
                 (?)

** In state 85, looking ahead at Semicolon, reducing production
** expr -> expr_single 
** is permitted because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 // lookahead token appears
                     expr_single . 

** In state 85, looking ahead at Semicolon, shifting is permitted
** because of the following sub-derivation:

Model LB3 Init Equal expr Semicolon Transition pattern Equal expr Semicolon loption(separated_nonempty_list(Semicolon,property)) RB3 
                     expr_single . Semicolon separated_nonempty_list(Semicolon,expr_single) 

** Conflict (shift/reduce) in state 80.
** Token involved: Iden
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal expr_single With LB3 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     expr_single With LB3 str_expr_list RB3 
                                                                          (?)

** In state 80, looking ahead at Iden, reducing production
** str_expr_list -> 
** is permitted because of the following sub-derivation:

str_expr_list Iden Equal expr Semicolon // lookahead token appears
. 

** In state 80, looking ahead at Iden, shifting is permitted
** because of the following sub-derivation:

. Iden Equal expr Semicolon 

** Conflict (shift/reduce) in state 71.
** Tokens involved: While Var Val UIden True Negb MinusDot Minus Match LB3 LB2 LB1 Int If Iden For Float False
** The following explanations concentrate on token Var.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal Iden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         (?)

** In state 71, looking ahead at Var, reducing production
** expr_single -> Iden 
** is permitted because of the following sub-derivation:

declars Var Iden option(type_of_expr) Equal expr_single // lookahead token appears
declars Var Iden option(type_of_expr) Equal expr_single // lookahead token is inherited
                                            Iden . 

** In state 71, looking ahead at Var, shifting is permitted
** because of the following sub-derivation:

declars Var Iden option(type_of_expr) Equal expr_single 
                                            Iden nonempty_list(expr_single) 
                                                 expr_single 
                                                 . Var Iden Equal expr_single 

** Conflict (shift/reduce) in state 62.
** Token involved: Iden
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal LB3 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                                                     LB3 str_expr_list RB3 
                                                         (?)

** In state 62, looking ahead at Iden, reducing production
** str_expr_list -> 
** is permitted because of the following sub-derivation:

str_expr_list Iden Equal expr Semicolon // lookahead token appears
. 

** In state 62, looking ahead at Iden, shifting is permitted
** because of the following sub-derivation:

. Iden Equal expr Semicolon 

** Conflict (shift/reduce) in state 56.
** Tokens involved: While Var Val UIden True Negb MinusDot Minus Match LB3 LB2 LB1 Int If Iden For Float False
** The following explanations concentrate on token Var.
** This state is reached from program after reading:

imported declars Var Iden option(type_of_expr) Equal UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         (?)

** In state 56, looking ahead at Var, reducing production
** expr_single -> UIden 
** is permitted because of the following sub-derivation:

declars Var Iden option(type_of_expr) Equal expr_single // lookahead token appears
declars Var Iden option(type_of_expr) Equal expr_single // lookahead token is inherited
                                            UIden . 

** In state 56, looking ahead at Var, shifting is permitted
** because of the following sub-derivation:

declars Var Iden option(type_of_expr) Equal expr_single 
                                            UIden expr_single 
                                                  . Var Iden Equal expr_single 

** Conflict (shift/reduce) in state 44.
** Tokens involved: TLst TAray Arrow
** The following explanations concentrate on token TLst.
** This state is reached from program after reading:

imported declars Var Iden Colon UIden typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                          type_of_expr 
                          Colon typ 
                                (?)

** In state 44, looking ahead at TLst, reducing production
** constr -> UIden typ 
** is permitted because of the following sub-derivation:

typ TLst // lookahead token appears
constrs // lookahead token is inherited
constr // lookahead token is inherited
UIden typ . 

** In state 44, looking ahead at TLst, shifting is permitted
** because of the following sub-derivation:

constrs 
constr 
UIden typ 
      typ . TLst 

** Conflict (shift/reduce) in state 26.
** Token involved: Vertical
** This state is reached from program after reading:

imported declars Var Iden Colon UIden constr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                          type_of_expr 
                          Colon typ 
                                constrs 
                                (?)

** In state 26, looking ahead at Vertical, reducing production
** constrs -> constr 
** is permitted because of the following sub-derivation:

constr Vertical constrs // lookahead token appears
UIden typ // lookahead token is inherited
      constrs // lookahead token is inherited
      constr . 

** In state 26, looking ahead at Vertical, shifting is permitted
** because of the following sub-derivation:

constr 
UIden typ 
      constrs 
      constr . Vertical constrs 

** Conflict (shift/reduce) in state 23.
** Tokens involved: TLst TAray
** The following explanations concentrate on token TLst.
** This state is reached from program after reading:

imported declars Var Iden Colon typ Arrow typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                          type_of_expr 
                          Colon typ 
                                (?)

** In state 23, looking ahead at TLst, shifting is permitted
** because of the following sub-derivation:

typ Arrow typ 
          typ . TLst 

** In state 23, looking ahead at TLst, reducing production
** typ -> typ Arrow typ 
** is permitted because of the following sub-derivation:

typ TLst // lookahead token appears
typ Arrow typ . 

** Conflict (shift/reduce) in state 19.
** Tokens involved: UIden TUnt TLst TInt TFloat TBool TAray LB3 LB1 Iden Arrow
** The following explanations concentrate on token TLst.
** This state is reached from program after reading:

imported declars Var Iden Colon Iden typ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                          type_of_expr 
                          Colon typ 
                                (?)

** In state 19, looking ahead at TLst, reducing production
** list(typ) -> 
** is permitted because of the following sub-derivation:

typ TLst // lookahead token appears
Iden list(typ) // lookahead token is inherited
     typ list(typ) // lookahead token is inherited
         . 

** In state 19, looking ahead at TLst, shifting is permitted
** because of the following sub-derivation:

Iden list(typ) 
     typ list(typ) 
     typ . TLst 

** Conflict (shift/reduce) in state 18.
** Tokens involved: UIden TUnt TInt TFloat TBool LB3 LB1 Iden
** The following explanations concentrate on token UIden.
** This state is reached from program after reading:

imported declars Var Iden Colon Iden Iden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                          type_of_expr 
                          Colon typ 
                                Iden list(typ) 
                                     (?)

** In state 18, looking ahead at UIden, shifting is permitted
** because of the following sub-derivation:

typ list(typ) 
Iden list(typ) 
     typ list(typ) 
     constrs 
     constr 
     . UIden 

** In state 18, looking ahead at UIden, reducing production
** list(typ) -> 
** is permitted because of the following sub-derivation:

typ list(typ) // lookahead token appears because list(typ) can begin with UIden
Iden list(typ) // lookahead token is inherited
     . 

** Conflict (shift/reduce) in state 9.
** Tokens involved: UIden TUnt TInt TFloat TBool LB3 LB1 Iden
** The following explanations concentrate on token UIden.
** This state is reached from program after reading:

imported declars Var Iden Colon Iden UIden 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
imported declars EOF 
         declars Var Iden option(type_of_expr) Equal expr_single 
                          type_of_expr 
                          Colon typ 
                                Iden list(typ) 
                                     (?)

** In state 9, looking ahead at UIden, shifting is permitted
** because of the following sub-derivation:

typ list(typ) 
constrs 
constr 
UIden typ 
      constrs 
      constr 
      . UIden 

** In state 9, looking ahead at UIden, reducing production
** constr -> UIden 
** is permitted because of the following sub-derivation:

typ list(typ) // lookahead token appears because list(typ) can begin with UIden
constrs // lookahead token is inherited
constr // lookahead token is inherited
UIden . 
